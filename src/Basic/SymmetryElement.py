import warnings
from attrs import frozen, field
from src.Basic.Atom import Atom

import mpmath as mpm

mpm.mp.mpds = 100
# Note that SymmetryElement objects very sensitive to parameter mpm.mp.dps

@frozen(slots=True, kw_only=True)
class SymmetryElementBase:
    """Frozen классы attrs удобно использовать для создания почти-неизменяемых классов.
    Здесь реализована вся логика инициализации SymmetryElement. See SymmetryElement.

    Raises:
        Exception: Если вращательная часть не 3х3 или трансялционная часть или тр не 3х1.

    See:
        * http://www.pci.tu-bs.de/aggericke/PC4e/Kap_IV/Matrix_Symm_Op.htm
        * https://www.cryst.ehu.es/html/resources/bogota2018/Bogota2018_3_SymmOper_Students.pdf
    """
    rotation: mpm.matrix = field(init=True, converter=mpm.matrix)
    translation: mpm.matrix = field(converter=mpm.matrix)
    translation_vector: mpm.matrix = field(converter=mpm.matrix)
    _n: int = field(init=False, default=0)

    def __attrs_post_init__(self):
        # This allows change translation aprt after object initialization
        object.__setattr__(self, "translation", self.reduce_translation_part(self.translation, self.translation_vector))

    @translation.default
    @translation_vector.default
    def _31_matrix(self):
        return mpm.matrix(3, 1)

    @rotation.validator
    def _check_rotation(self, attributes, value):
        if value.rows != value.cols or value.cols != 3:
            raise Exception(
                f"Rotational part of symmetry element shoud be mpmath.matrix 3x3 size instead {value}"
            )

    @translation.validator
    def _check_translation(self, attributes, value):
        if value.cols != 1 or value.rows != 3:
            raise Exception(
                "Translational part shoud be mpmath.matrix 3x1 size"
            )

    @translation_vector.validator
    def _check_tv(self, attributes, value):
        if value.cols != 1 or value.rows != 3:
            raise Exception(
                "Translational vector shoud be mpmath.matrix 3x1 size"
            )

    @classmethod
    def reduce_translation_part(cls, tp:mpm.matrix, tv:mpm.matrix) -> mpm.matrix:
        """Уменьшает трансляционную часть на n*A, - где A - вектор трансляции сиситемы.
        Если вектор трансляции равен 0 -> вернёт нулевой вектор.
        """
        new_tp = mpm.matrix(3, 1)
        for i in range(3):
            if mpm.almosteq(tv[i], 0, abs_eps=1e-8):
                new_tp[i] = 0
            else:
                new_tp[i] = mpm.fsub(tp[i], mpm.fmul(tv[i], int(mpm.fdiv(tp[i], tv[i]))))

        return new_tp


class SymmetryElement(SymmetryElementBase):
    # TODO: Docstring

    def _order(self, limit=1000, tol=1e-10):
        for i in range(1, limit + 1):
            delta = self.rotation**i - mpm.diag([1, 1, 1])
            if all(mpm.almosteq(delta[i, i], 0, abs_eps=tol) for i in range(2 + 1)):
                object.__setattr__(self, '_n', i)
                return i

    @property
    def order(self, limit=1000, tol=1e-10):
        """Return q if given, else try to find element order."""
        return self._n or self._order(limit=limit, tol=tol)

    def apply(self, atom: Atom) -> Atom:
        """Apply symmetry element to given atom and return new one.s"""
        return Atom(atom.atom, coordinates=mpm.chop((self.rotation * atom.coordinates) + self.translation))

    def rotation_eq(self, other) -> bool:
        """Check if rotational part of two symmetry elements are equal."""

        delta_rot = self.rotation - other.rotation
        # check if all elements in delta_rot is almost equal to 0
        return all(
            mpm.almosteq(delta_rot[i, j], 0, abs_eps=10 ** -(mpm.mp.dps - 2))
            for i in range(2 + 1)
            for j in range(2 + 1))

    def get_all_powers(self) -> tuple:
        """Return all elements of group generated by this symmetry element.

        Raises:
            ValueError: if order of given symmetry element is not defined properly.
        """
        n = self.order
        if n == float("inf"):
            raise ValueError(f"Order of element {self} to big or cannot be defined")
        return tuple(self**i for i in range(0, n))

    def translation_eq(self, other):
        """Check if translation part of two symmetry elements differ by translation vector"""
        if self.translation_vector == other.translation_vector:
            tp1 = self.reduce_translation_part(self.translation, self.translation_vector)
            tp2 = self.reduce_translation_part(other.translation, self.translation_vector)
            eq = tp1 == tp2
        else:
            eq = False
        return eq

    def __eq__(self, other):
        """Check if rotational part and translational part of symmetry elements is exacly the same"""
        if isinstance(other, SymmetryElement):
            return self.rotation_eq(other) and self.translation_eq(other)
        else:
            raise Exception(f'Only symmetry elements can be compared, not {type(other)}')

    def __repr__(self):
        """Representation of symmetry element taken from Crystal17 .f34 file
        """
        rot_ = "{:^20.12E}{:^20.12E}{:^20.12E}\n{:^20.12E}{:^20.12E}{:^20.12E}\n{:^20.12E}{:^20.12E}{:^20.12E}\n".format(
            *[float(mpm.chop(i, tol=1e-15)) for i in self.rotation]
        )
        rot_trans_ = rot_ + "{:^20.12E}{:^20.12E}{:^20.12E}\n".format(
            *[float(mpm.chop(i, tol=1e-15)) for i in self.translation]
        )
        return rot_trans_

    def __mul__(self, other):
        """Produce new symmetry element"""
        if isinstance(other, SymmetryElement):
            # * Вектора трансляции элементов симметрии должны быть равны или 
            # * один из них может быть равным нулю, в этом случае вектор трансляции нового элемента симметрии
            # * присвается ненулевым
            if all(mpm.almosteq(i, j, abs_eps=1e-15) for i, j in zip(self.translation_vector, other.translation_vector)):
                new_tv = self.translation_vector
            else:
                if self.translation_vector == mpm.matrix(3, 1):
                    new_tv = other.translation_vector
                elif other.translation_vector == mpm.matrix(3, 1):
                    new_tv = self.translation_vector
                else:
                    raise ValueError(f'Translation vectors of two symmetry elements does not equal\n{self} != \n{other}')
            mpm.mp.dps += 10
            new_rotation = self.rotation * other.rotation
            new_translation = self.rotation * other.translation + self.translation
            mpm.mp.dps -= 10
        else:
            raise ValueError(
                "Symmetry element can be multiplied only for another symmetry element"
            )
        return SymmetryElement(rotation=new_rotation, translation=new_translation, translation_vector=new_tv)

    def __hash__(self):
        return hash(str(self))

    def __pow__(self, other:int):
        """Return power of curent symmentry element.
        """

        new_rotation = self.rotation**other
        new_translation = self.translation * other
        return SymmetryElement(rotation=new_rotation, translation=new_translation, translation_vector=self.translation_vector)
